<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Grid Bot Market Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .glassmorphism {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
        .alert-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .7; }
        }
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #6366f1;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .trend-up { color: #10b981; }
        .trend-down { color: #ef4444; }
        .trend-neutral { color: #f59e0b; }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <div class="container mx-auto p-4 md:p-8">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-indigo-600">
                Advanced Grid Bot Market Analyzer
            </h1>
            <p class="text-gray-400 mt-2">AI-powered market analysis for optimal grid bot deployment</p>
            <div class="mt-4 flex justify-center gap-4">
                <span class="text-sm px-3 py-1 bg-green-600/20 text-green-400 rounded-full">
                    Status: <span id="connection-status">Active</span>
                </span>
                <span class="text-sm px-3 py-1 bg-blue-600/20 text-blue-400 rounded-full">
                    Last Update: <span id="last-update">--:--:--</span>
                </span>
            </div>
        </header>

        <!-- Market Condition Dashboard -->
        <section class="mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-300">Overall Market Conditions</h2>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div class="glassmorphism p-4 rounded-lg">
                    <p class="text-gray-400 text-sm">Market Trend</p>
                    <p class="text-2xl font-bold" id="market-trend">--</p>
                    <p class="text-sm mt-1" id="trend-strength">--</p>
                    <div class="mt-2 h-2 bg-gray-700 rounded-full">
                        <div id="trend-bar" class="h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
                    </div>
                </div>
                <div class="glassmorphism p-4 rounded-lg">
                    <p class="text-gray-400 text-sm">Fear & Greed Index</p>
                    <p class="text-2xl font-bold" id="fear-greed">--</p>
                    <p class="text-sm" id="fg-label">--</p>
                </div>
                <div class="glassmorphism p-4 rounded-lg">
                    <p class="text-gray-400 text-sm">BTC Dominance</p>
                    <p class="text-2xl font-bold" id="btc-dominance">--%</p>
                    <p class="text-sm" id="dom-change">--</p>
                </div>
                <div class="glassmorphism p-4 rounded-lg">
                    <p class="text-gray-400 text-sm">Market Phase</p>
                    <p class="text-2xl font-bold" id="market-phase">--</p>
                    <p class="text-sm" id="phase-desc">--</p>
                </div>
            </div>
        </section>

        <!-- Technical Analysis Overview -->
        <section class="mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-300">Technical Analysis Overview</h2>
            <div class="glassmorphism p-6 rounded-lg">
                <canvas id="market-chart" height="80"></canvas>
            </div>
        </section>

        <!-- Grid Bot Opportunities -->
        <section id="analyzer-section">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-300">Grid Bot Opportunities</h2>
            
            <!-- Filters -->
            <div class="flex flex-wrap items-center justify-between gap-4 mb-6 p-4 rounded-lg bg-gray-800 shadow-lg">
                <div class="flex gap-4 flex-wrap">
                    <div>
                        <label class="text-gray-400 mr-2">Exchange:</label>
                        <select id="exchange-filter" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white">
                            <option value="all">All Exchanges</option>
                            <option value="Binance">Binance</option>
                            <option value="Bybit">Bybit</option>
                            <option value="Bitget">Bitget</option>
                        </select>
                    </div>
                    <div>
                        <label class="text-gray-400 mr-2">Market Condition:</label>
                        <select id="condition-filter" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white">
                            <option value="all">All Conditions</option>
                            <option value="trending">Trending</option>
                            <option value="ranging">Ranging</option>
                            <option value="volatile">High Volatility</option>
                        </select>
                    </div>
                    <div>
                        <label class="text-gray-400 mr-2">Timeframe:</label>
                        <select id="timeframe-filter" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white">
                            <option value="1h">1 Hour</option>
                            <option value="4h">4 Hours</option>
                            <option value="1d">1 Day</option>
                        </select>
                    </div>
                    <div>
                        <label class="text-gray-400 mr-2">Min Score:</label>
                        <input type="range" id="score-filter" min="0" max="100" value="50" 
                               class="w-32 align-middle">
                        <span id="score-value" class="ml-2">50</span>
                    </div>
                </div>
                <div class="flex gap-2">
                    <select id="data-source" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white">
                        <option value="auto">Auto</option>
                        <option value="live">Live API</option>
                        <option value="demo">Demo Data</option>
                    </select>
                    <button id="refresh-analysis" class="bg-indigo-600 hover:bg-indigo-700 px-4 py-2 rounded-lg transition">
                        Refresh Analysis
                    </button>
                </div>
            </div>

            <!-- Analysis Table -->
            <div class="overflow-x-auto rounded-lg shadow-2xl glassmorphism">
                <table class="w-full text-sm text-left text-gray-300">
                    <thead class="text-xs text-gray-200 uppercase bg-gray-800/50">
                        <tr>
                            <th class="px-6 py-3">Pair</th>
                            <th class="px-6 py-3">Trend</th>
                            <th class="px-6 py-3">Price</th>
                            <th class="px-6 py-3">24h Change</th>
                            <th class="px-6 py-3">Indicators</th>
                            <th class="px-6 py-3">Volatility</th>
                            <th class="px-6 py-3">Funding</th>
                            <th class="px-6 py-3">Score</th>
                            <th class="px-6 py-3">Recommendation</th>
                            <th class="px-6 py-3 text-center">Action</th>
                        </tr>
                    </thead>
                    <tbody id="opportunities-table">
                        <tr>
                            <td colspan="10" class="text-center p-8">
                                <div class="loading-spinner mx-auto"></div>
                                <p class="mt-4">Analyzing market conditions...</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Active Monitoring Section -->
        <section class="mt-12">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-300">Active Bot Monitoring & Alerts</h2>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Alert Settings -->
                <div class="glassmorphism p-6 rounded-lg">
                    <h3 class="text-xl font-semibold mb-4">Alert Configuration</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="alert-trend-change" checked class="mr-2">
                                <span>Alert on Trend Change</span>
                            </label>
                        </div>
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="alert-volatility" checked class="mr-2">
                                <span>Alert on Volatility Spike (>15%)</span>
                            </label>
                        </div>
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="alert-funding" checked class="mr-2">
                                <span>Alert on Funding Rate Flip</span>
                            </label>
                        </div>
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="alert-indicators" checked class="mr-2">
                                <span>Alert on Indicator Divergence</span>
                            </label>
                        </div>
                        <div class="mt-4">
                            <label class="block text-sm text-gray-400 mb-2">Notification Method</label>
                            <select class="w-full bg-gray-700 rounded p-2">
                                <option>Dashboard Only</option>
                                <option>Email</option>
                                <option>Telegram</option>
                                <option>Webhook</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Recent Alerts -->
                <div class="glassmorphism p-6 rounded-lg">
                    <h3 class="text-xl font-semibold mb-4">Recent Alerts</h3>
                    <div id="alerts-container" class="space-y-3 max-h-64 overflow-y-auto">
                        <!-- Alerts will be populated here -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Account Information Section -->
        <section class="mt-12">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-300">Account Information</h2>
            <div class="glassmorphism p-6 rounded-lg">
                <button id="fetch-balance-btn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg transition disabled:bg-gray-500">
                    Fetch Bitget Wallet Balance
                </button>
                <div id="account-info-container" class="mt-4 text-gray-400">
                    Click the button to load account details...
                </div>
            </div>
        </section>

        <!-- Strategy Recommendations -->
        <section class="mt-12">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-300">AI Strategy Recommendations</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div class="glassmorphism p-6 rounded-lg border-2 border-green-500/30">
                    <h3 class="text-xl font-semibold text-green-400 mb-3">Best Opportunities</h3>
                    <div id="best-opportunities" class="space-y-3">
                        <!-- Will be populated -->
                    </div>
                </div>
                <div class="glassmorphism p-6 rounded-lg border-2 border-yellow-500/30">
                    <h3 class="text-xl font-semibold text-yellow-400 mb-3">Exit Signals</h3>
                    <div id="exit-signals" class="space-y-3">
                        <!-- Will be populated -->
                    </div>
                </div>
                <div class="glassmorphism p-6 rounded-lg border-2 border-red-500/30">
                    <h3 class="text-xl font-semibold text-red-400 mb-3">Risk Warnings</h3>
                    <div id="risk-warnings" class="space-y-3">
                        <!-- Will be populated -->
                    </div>
                </div>
            </div>
        </section>
    </div>

    <!-- Modal Container -->
    <div id="modal-container"></div>

    <script>
        // Global state
        let marketData = [];
        let chartInstance = null;
        let alerts = [];
        let monitoredPairs = new Set();

        // Technical indicators calculation
        class TechnicalIndicators {
            static calculateRSI(prices, period = 14) {
                if (prices.length < period) return 50;
                
                let gains = 0, losses = 0;
                for (let i = 1; i <= period; i++) {
                    const diff = prices[i] - prices[i - 1];
                    if (diff > 0) gains += diff;
                    else losses -= diff;
                }
                
                const avgGain = gains / period;
                const avgLoss = losses / period;
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            }

            static calculateMA(prices, period) {
                if (prices.length < period) return prices[prices.length - 1];
                const sum = prices.slice(-period).reduce((a, b) => a + b, 0);
                return sum / period;
            }

            static calculateBollingerBands(prices, period = 20, stdDev = 2) {
                const ma = this.calculateMA(prices, period);
                const variance = prices.slice(-period).reduce((sum, price) => {
                    return sum + Math.pow(price - ma, 2);
                }, 0) / period;
                const std = Math.sqrt(variance);
                
                return {
                    upper: ma + (stdDev * std),
                    middle: ma,
                    lower: ma - (stdDev * std)
                };
            }

            static calculateMACD(prices) {
                const ema12 = this.calculateEMA(prices, 12);
                const ema26 = this.calculateEMA(prices, 26);
                const macd = ema12 - ema26;
                const signal = this.calculateEMA([macd], 9);
                return { macd, signal, histogram: macd - signal };
            }

            static calculateEMA(prices, period) {
                if (prices.length === 0) return 0;
                const multiplier = 2 / (period + 1);
                let ema = prices[0];
                
                for (let i = 1; i < prices.length; i++) {
                    ema = (prices[i] - ema) * multiplier + ema;
                }
                return ema;
            }

            static detectTrend(prices) {
                if (prices.length < 20) return { direction: 'neutral', strength: 0 };
                
                const ma20 = this.calculateMA(prices, 20);
                const ma50 = this.calculateMA(prices, Math.min(50, prices.length));
                const currentPrice = prices[prices.length - 1];
                
                let direction = 'neutral';
                let strength = 0;
                
                if (currentPrice > ma20 && ma20 > ma50) {
                    direction = 'bullish';
                    strength = ((currentPrice - ma50) / ma50) * 100;
                } else if (currentPrice < ma20 && ma20 < ma50) {
                    direction = 'bearish';
                    strength = ((ma50 - currentPrice) / ma50) * 100;
                }
                
                return { direction, strength: Math.min(strength, 100) };
            }
        }

        // Market analysis functions
        function analyzeMarketCondition(data) {
            // Handle both array of prices and object with priceHistory
            const prices = Array.isArray(data) ? data : (data.priceHistory || [data.price]);
            
            if (!prices || prices.length === 0) {
                return {
                    trend: { direction: 'neutral', strength: 0 },
                    rsi: 50,
                    bb: { upper: 0, middle: 0, lower: 0 },
                    volatility: 0,
                    phase: 'Unknown',
                    phaseDesc: 'Insufficient data'
                };
            }
            
            const trend = TechnicalIndicators.detectTrend(prices);
            const rsi = TechnicalIndicators.calculateRSI(prices);
            const bb = TechnicalIndicators.calculateBollingerBands(prices);
            const volatility = calculateVolatility(prices);
            
            // Determine market phase
            let phase = 'Neutral';
            let phaseDesc = '';
            
            if (trend.direction === 'bullish' && rsi < 70) {
                phase = 'Accumulation';
                phaseDesc = 'Good for long grid bots';
            } else if (trend.direction === 'bullish' && rsi > 70) {
                phase = 'Distribution';
                phaseDesc = 'Consider taking profits';
            } else if (trend.direction === 'bearish' && rsi > 30) {
                phase = 'Markdown';
                phaseDesc = 'Good for short grid bots';
            } else if (volatility > 5 && Math.abs(prices[prices.length - 1] - bb.middle) < bb.middle * 0.02) {
                phase = 'Ranging';
                phaseDesc = 'Ideal for neutral grid bots';
            }
            
            return { trend, rsi, bb, volatility, phase, phaseDesc };
        }

        function calculateVolatility(prices) {
            if (prices.length < 2) return 0;
            const returns = [];
            for (let i = 1; i < prices.length; i++) {
                returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
            }
            const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
            const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
            return Math.sqrt(variance * 252) * 100; // Annualized volatility
        }

        // API Configuration - Update this after setting up backend proxy
        const API_CONFIG = {
            backendUrl: 'https://grid-bot-backend-your-username.vercel.app', // Replace with your Vercel URL
            
            // Direct API endpoints (will face CORS issues)
            direct: {
                binance: {
                    futures: 'https://fapi.binance.com/fapi/v1',
                    spot: 'https://api.binance.com/api/v3',
                    fundingEndpoint: '/fundingRate',
                    klinesEndpoint: '/klines'
                },
                bybit: {
                    base: 'https://api.bybit.com/v5',
                    tickersEndpoint: '/market/tickers',
                    fundingEndpoint: '/market/funding/history',
                    klinesEndpoint: '/market/kline'
                },
                bitget: {
                    base: 'https://api.bitget.com/api/mix/v1',
                    tickersEndpoint: '/market/tickers',
                    fundingEndpoint: '/market/current-fundRate',
                    klinesEndpoint: '/market/candles'
                }
            },
            
            // Proxy endpoints (use these when backend is set up)
            proxy: {
                binance: {
                    klines: '/api/binance/futures/klines',
                    funding: '/api/binance/futures/fundingRate',
                    ticker: '/api/binance/futures/ticker'
                },
                bybit: {
                    tickers: '/api/bybit/market/tickers',
                    klines: '/api/bybit/market/kline'
                },
                bitget: {
                    tickers: '/api/bitget/market/tickers',
                    funding: '/api/bitget/market/fundingRate'
                },
                combined: '/api/market-data'
            }
        };

        // Check if backend proxy is available
        async function checkBackendConnection() {
            if (!API_CONFIG.backendUrl) {
                return false;
            }
            
            try {
                const response = await axios.get(`${API_CONFIG.backendUrl}/health`, { timeout: 3000 });
                return response.data.status === 'OK';
            } catch (error) {
                return false;
            }
        }

        // Exchange API Functions with proxy support
        async function fetchBinanceData(symbol) {
            try {
                const useProxy = API_CONFIG.backendUrl && await checkBackendConnection();
                
                if (useProxy) {
                    // Use proxy endpoints
                    const [klinesResponse, fundingResponse] = await Promise.all([
                        axios.get(`${API_CONFIG.backendUrl}${API_CONFIG.proxy.binance.klines}`, {
                            params: {
                                symbol: symbol.replace('/', ''),
                                interval: '1h',
                                limit: 100
                            }
                        }),
                        axios.get(`${API_CONFIG.backendUrl}${API_CONFIG.proxy.binance.funding}`, {
                            params: {
                                symbol: symbol.replace('/', ''),
                                limit: 1
                            }
                        })
                    ]);
                    
                    const klines = klinesResponse.data;
                    const priceHistory = klines.map(k => parseFloat(k[4]));
                    const currentPrice = priceHistory[priceHistory.length - 1];
                    const fundingRate = fundingResponse.data[0] ? parseFloat(fundingResponse.data[0].fundingRate) : 0;
                    
                    return {
                        exchange: 'Binance',
                        symbol,
                        currentPrice,
                        priceHistory,
                        fundingRate,
                        volume24h: parseFloat(klines[klines.length - 1][5])
                    };
                } else {
                    // Try direct API (will likely fail due to CORS)
                    throw new Error('Backend proxy not configured. Please set up the backend server.');
                }
            } catch (error) {
                console.error(`Error fetching Binance data for ${symbol}:`, error.message);
                throw error;
            }
        }

        async function fetchBybitData(symbol) {
            try {
                // Fetch ticker data
                const tickerResponse = await axios.get(`${API_CONFIG.bybit.base}${API_CONFIG.bybit.tickersEndpoint}`, {
                    params: {
                        category: 'linear',
                        symbol: symbol.replace('/', '')
                    }
                });
                
                // Fetch klines
                const klinesResponse = await axios.get(`${API_CONFIG.bybit.base}${API_CONFIG.bybit.klinesEndpoint}`, {
                    params: {
                        category: 'linear',
                        symbol: symbol.replace('/', ''),
                        interval: '60',
                        limit: 100
                    }
                });
                
                const ticker = tickerResponse.data.result.list[0];
                const klines = klinesResponse.data.result.list;
                const priceHistory = klines.map(k => parseFloat(k[4])).reverse(); // Close prices
                
                return {
                    exchange: 'Bybit',
                    symbol,
                    currentPrice: parseFloat(ticker.lastPrice),
                    priceHistory,
                    fundingRate: parseFloat(ticker.fundingRate || 0),
                    volume24h: parseFloat(ticker.volume24h)
                };
            } catch (error) {
                console.error(`Error fetching Bybit data for ${symbol}:`, error);
                return null;
            }
        }

        async function fetchBitgetData(symbol) {
            try {
                // Fetch ticker data
                const tickerResponse = await axios.get(`${API_CONFIG.bitget.base}${API_CONFIG.bitget.tickersEndpoint}`, {
                    params: {
                        productType: 'umcbl'
                    }
                });
                
                // Find the specific symbol
                const ticker = tickerResponse.data.data.find(t => t.symbol === symbol.replace('/', '') + '_UMCBL');
                
                if (!ticker) throw new Error(`Symbol ${symbol} not found on Bitget`);
                
                // Fetch funding rate
                const fundingResponse = await axios.get(`${API_CONFIG.bitget.base}${API_CONFIG.bitget.fundingEndpoint}`, {
                    params: {
                        symbol: symbol.replace('/', '') + '_UMCBL'
                    }
                });
                
                return {
                    exchange: 'Bitget',
                    symbol,
                    currentPrice: parseFloat(ticker.last),
                    priceHistory: [], // Would need separate klines request
                    fundingRate: parseFloat(fundingResponse.data.data.fundingRate || 0),
                    volume24h: parseFloat(ticker.volume)
                };
            } catch (error) {
                console.error(`Error fetching Bitget data for ${symbol}:`, error);
                return null;
            }
        }

        // Fetch data from all exchanges
        async function fetchMarketDataFromAPIs() {
            const symbols = ['BTC/USDT', 'ETH/USDT', 'SOL/USDT', 'AVAX/USDT', 'MATIC/USDT'];
            const allData = [];
            
            for (const symbol of symbols) {
                // Fetch from multiple exchanges
                const [binanceData, bybitData, bitgetData] = await Promise.all([
                    fetchBinanceData(symbol),
                    fetchBybitData(symbol),
                    fetchBitgetData(symbol)
                ]);
                
                // Process each exchange's data
                [binanceData, bybitData, bitgetData].forEach(data => {
                    if (data && data.priceHistory.length > 0) {
                        const analysis = analyzeMarketCondition({ priceHistory: data.priceHistory });
                        const indicators = {
                            rsi: TechnicalIndicators.calculateRSI(data.priceHistory),
                            macd: TechnicalIndicators.calculateMACD(data.priceHistory),
                            bb: TechnicalIndicators.calculateBollingerBands(data.priceHistory)
                        };
                        
                        // Calculate score and recommendation
                        let recommendation = 'Neutral Grid';
                        let score = 50;
                        
                        if (analysis.trend.direction === 'bullish' && data.fundingRate < 0.0001) {
                            recommendation = 'Long Grid';
                            score = 75 + Math.random() * 25;
                        } else if (analysis.trend.direction === 'bearish' && data.fundingRate > 0.0001) {
                            recommendation = 'Short Grid';
                            score = 75 + Math.random() * 25;
                        } else if (analysis.volatility > 5 && Math.abs(data.fundingRate) < 0.0001) {
                            recommendation = 'Neutral Grid';
                            score = 80 + Math.random() * 20;
                        } else if (analysis.volatility < 2) {
                            recommendation = 'Not Recommended';
                            score = 20 + Math.random() * 30;
                        }
                        
                        allData.push({
                            pair: data.symbol,
                            exchange: data.exchange,
                            price: data.currentPrice,
                            priceHistory: data.priceHistory,
                            change24h: data.priceHistory.length > 24 ? 
                                ((data.currentPrice - data.priceHistory[data.priceHistory.length - 24]) / data.priceHistory[data.priceHistory.length - 24] * 100) : 0,
                            trend: analysis.trend,
                            indicators: {
                                rsi: indicators.rsi,
                                macd: indicators.macd.histogram > 0 ? 'Bullish' : 'Bearish',
                                bb: indicators.bb
                            },
                            volatility: analysis.volatility,
                            fundingRate: data.fundingRate,
                            score,
                            recommendation,
                            phase: analysis.phase,
                            volume24h: data.volume24h
                        });
                    }
                });
            }
            
            return allData;
        }

        // Fallback to simulated data if APIs fail
        function generateMarketData() {
            const pairs = [
                'BTC/USDT', 'ETH/USDT', 'BNB/USDT', 'SOL/USDT', 'ADA/USDT',
                'AVAX/USDT', 'DOT/USDT', 'MATIC/USDT', 'LINK/USDT', 'UNI/USDT',
                'ATOM/USDT', 'LTC/USDT', 'FTM/USDT', 'NEAR/USDT', 'ALGO/USDT'
            ];
            
            const exchanges = ['Binance', 'Bybit', 'Bitget'];
            const allData = [];
            
            pairs.forEach(pair => {
                exchanges.forEach(exchange => {
                    // Generate price history
                    const basePrice = getBasePrice(pair);
                    const priceHistory = [];
                    let currentPrice = basePrice;
                    
                    for (let i = 0; i < 100; i++) {
                        currentPrice *= (1 + (Math.random() - 0.5) * 0.02);
                        priceHistory.push(currentPrice);
                    }
                    
                    const analysis = analyzeMarketCondition({ priceHistory });
                    const fundingRate = (Math.random() - 0.5) * 0.0006; // More realistic funding rates
                    
                    // Calculate indicators
                    const rsi = TechnicalIndicators.calculateRSI(priceHistory);
                    const macd = TechnicalIndicators.calculateMACD(priceHistory);
                    const bb = TechnicalIndicators.calculateBollingerBands(priceHistory);
                    
                    // Determine recommendation
                    let recommendation = 'Neutral Grid';
                    let score = 50;
                    
                    if (analysis.trend.direction === 'bullish' && fundingRate < 0.0001) {
                        recommendation = 'Long Grid';
                        score = 75 + Math.random() * 25;
                    } else if (analysis.trend.direction === 'bearish' && fundingRate > 0.0001) {
                        recommendation = 'Short Grid';
                        score = 75 + Math.random() * 25;
                    } else if (analysis.volatility > 5 && Math.abs(fundingRate) < 0.0001) {
                        recommendation = 'Neutral Grid';
                        score = 80 + Math.random() * 20;
                    } else if (analysis.volatility < 2) {
                        recommendation = 'Not Recommended';
                        score = 20 + Math.random() * 30;
                    }
                    
                    allData.push({
                        pair,
                        exchange,
                        price: currentPrice,
                        priceHistory,
                        change24h: ((currentPrice - priceHistory[76]) / priceHistory[76] * 100),
                        trend: analysis.trend,
                        indicators: { rsi, macd: macd.histogram > 0 ? 'Bullish' : 'Bearish', bb },
                        volatility: analysis.volatility,
                        fundingRate,
                        score,
                        recommendation,
                        phase: analysis.phase,
                        volume24h: Math.random() * 100000000
                    });
                });
            });
            
            return allData;
        }

        function getBasePrice(pair) {
            const prices = {
                'BTC/USDT': 45000, 'ETH/USDT': 2500, 'BNB/USDT': 320,
                'SOL/USDT': 100, 'ADA/USDT': 0.5, 'AVAX/USDT': 35,
                'DOT/USDT': 7, 'MATIC/USDT': 0.8, 'LINK/USDT': 15,
                'UNI/USDT': 6, 'ATOM/USDT': 10, 'LTC/USDT': 70,
                'FTM/USDT': 0.4, 'NEAR/USDT': 3, 'ALGO/USDT': 0.2
            };
            return prices[pair] || 1;
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            initializeMarket();
            setupEventListeners();
            startRealTimeUpdates();
        });

        async function initializeMarket() {
            try {
                // Show loading state
                showNotification('info', 'Attempting to connect to live APIs...');
                
                // Try to fetch real data from APIs
                const liveData = await fetchMarketDataFromAPIs();
                
                if (liveData && liveData.length > 0) {
                    marketData = liveData;
                    document.getElementById('connection-status').textContent = 'Live';
                    document.getElementById('connection-status').parentElement.className = 
                        'text-sm px-3 py-1 bg-green-600/20 text-green-400 rounded-full';
                    showNotification('success', 'Successfully connected to live market data');
                } else {
                    // Fall back to simulated data
                    marketData = generateMarketData();
                    document.getElementById('connection-status').textContent = 'Demo Mode';
                    document.getElementById('connection-status').parentElement.className = 
                        'text-sm px-3 py-1 bg-yellow-600/20 text-yellow-400 rounded-full';
                    showNotification('warning', 'Live APIs unavailable. Using demo data. Note: Direct API calls may be blocked by CORS. See console for setup instructions.');
                    
                    // Log detailed setup instructions
                    console.log(`
=== API SETUP INSTRUCTIONS ===

Direct API calls from browsers are blocked by CORS policy.
To use live data, you need to set up a backend proxy server.

Follow the complete setup guide below:

1. BACKEND PROXY SETUP (Node.js/Express)
2. API KEY CONFIGURATION
3. FRONTEND INTEGRATION

See detailed instructions in the console below...
                    `);
                    logSetupInstructions();
                }
            } catch (error) {
                console.error('Error initializing market data:', error);
                // Use simulated data as fallback
                marketData = generateMarketData();
                document.getElementById('connection-status').textContent = 'Demo Mode';
                document.getElementById('connection-status').parentElement.className = 
                    'text-sm px-3 py-1 bg-red-600/20 text-red-400 rounded-full';
                showNotification('error', `Failed to connect to APIs: ${error.message}. Using demo data instead.`);
            }
            
            updateMarketOverview();
            renderOpportunitiesTable();
            initializeChart();
            updateRecommendations();
        }

        // Notification system
        function showNotification(type, message) {
            const notificationContainer = document.getElementById('notification-container') || createNotificationContainer();
            
            const notification = document.createElement('div');
            notification.className = `notification ${type} p-4 rounded-lg mb-2 shadow-lg transform transition-all duration-500 translate-x-full`;
            
            const colors = {
                'success': 'bg-green-600',
                'error': 'bg-red-600',
                'warning': 'bg-yellow-600',
                'info': 'bg-blue-600'
            };
            
            notification.innerHTML = `
                <div class="${colors[type]} text-white flex items-center justify-between">
                    <span>${message}</span>
                    <button onclick="this.parentElement.parentElement.remove()" class="ml-4 text-xl">&times;</button>
                </div>
            `;
            
            notificationContainer.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
                notification.classList.add('translate-x-0');
            }, 100);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => notification.remove(), 500);
            }, 5000);
        }

        function createNotificationContainer() {
            const container = document.createElement('div');
            container.id = 'notification-container';
            container.className = 'fixed top-4 right-4 z-50 w-96';
            document.body.appendChild(container);
            return container;
        }

        function logSetupInstructions() {
            console.log(`
=====================================
COMPLETE API SETUP GUIDE
=====================================

STEP 1: CREATE BACKEND PROXY SERVER
-----------------------------------

1. Create a new directory for your backend:
   mkdir grid-bot-backend
   cd grid-bot-backend

2. Initialize npm and install dependencies:
   npm init -y
   npm install express cors axios dotenv
   npm install -D nodemon

3. Create server.js file with this code:

const express = require('express');
const cors = require('cors');
const axios = require('axios');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3001;

// Enable CORS
app.use(cors());
app.use(express.json());

// Health check endpoint
app.get('/health', (req, res) => {
    res.json({ status: 'OK', message: 'Grid Bot API Proxy Running' });
});

// Binance endpoints
app.get('/api/binance/futures/klines', async (req, res) => {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/klines', {
            params: req.query
        });
        res.json(response.data);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/binance/futures/fundingRate', async (req, res) => {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/fundingRate', {
            params: req.query
        });
        res.json(response.data);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Bybit endpoints
app.get('/api/bybit/market/tickers', async (req, res) => {
    try {
        const response = await axios.get('https://api.bybit.com/v5/market/tickers', {
            params: req.query
        });
        res.json(response.data);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/bybit/market/kline', async (req, res) => {
    try {
        const response = await axios.get('https://api.bybit.com/v5/market/kline', {
            params: req.query
        });
        res.json(response.data);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Bitget endpoints (requires API key)
app.get('/api/bitget/market/tickers', async (req, res) => {
    try {
        const response = await axios.get('https://api.bitget.com/api/mix/v1/market/tickers', {
            params: req.query,
            headers: {
                'ACCESS-KEY': process.env.BITGET_API_KEY || '',
                'ACCESS-PASSPHRASE': process.env.BITGET_PASSPHRASE || ''
            }
        });
        res.json(response.data);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Combined market data endpoint
app.get('/api/market-data', async (req, res) => {
    try {
        const { symbols = 'BTCUSDT,ETHUSDT,SOLUSDT' } = req.query;
        const symbolList = symbols.split(',');
        
        const results = [];
        
        // Fetch from multiple exchanges in parallel
        for (const symbol of symbolList) {
            const [binanceData, bybitData] = await Promise.all([
                // Binance
                axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
                    params: { symbol }
                }).catch(err => null),
                
                // Bybit
                axios.get('https://api.bybit.com/v5/market/tickers', {
                    params: { category: 'linear', symbol }
                }).catch(err => null)
            ]);
            
            if (binanceData) {
                results.push({
                    exchange: 'Binance',
                    symbol,
                    data: binanceData.data
                });
            }
            
            if (bybitData && bybitData.data.result.list.length > 0) {
                results.push({
                    exchange: 'Bybit',
                    symbol,
                    data: bybitData.data.result.list[0]
                });
            }
        }
        
        res.json(results);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.listen(PORT, () => {
    console.log(\`Grid Bot API Proxy running on port \${PORT}\`);
});

4. Create .env file:
   BITGET_API_KEY=your_bitget_api_key_here
   BITGET_PASSPHRASE=your_passphrase_here
   PORT=3001

5. Update package.json scripts:
   "scripts": {
     "start": "node server.js",
     "dev": "nodemon server.js"
   }

6. Start the server:
   npm run dev

=====================================
STEP 2: GET API KEYS (Optional)
=====================================

Most endpoints work without API keys, but for full access:

BINANCE:
1. Go to https://www.binance.com/en/my/settings/api-management
2. Create new API key
3. Enable "Enable Futures" permission
4. Save API Key and Secret

BYBIT:
1. Go to https://www.bybit.com/app/user/api-management
2. Create new API key
3. Set permissions: "Read" for Contract Trade
4. Save API Key and Secret

BITGET:
1. Go to https://www.bitget.com/en/account/api
2. Create new API key
3. Set permissions: "Read" for Futures
4. Save API Key, Secret, and Passphrase

=====================================
STEP 3: UPDATE FRONTEND CODE
=====================================

Replace the API_CONFIG in your frontend with:

const API_CONFIG = {
    backendUrl: 'http://localhost:3001',
    endpoints: {
        binance: {
            klines: '/api/binance/futures/klines',
            funding: '/api/binance/futures/fundingRate'
        },
        bybit: {
            tickers: '/api/bybit/market/tickers',
            klines: '/api/bybit/market/kline'
        },
        marketData: '/api/market-data'
    }
};

Then update fetch functions to use your proxy:

async function fetchBinanceData(symbol) {
    try {
        const response = await axios.get(\`\${API_CONFIG.backendUrl}\${API_CONFIG.endpoints.binance.klines}\`, {
            params: {
                symbol: symbol.replace('/', ''),
                interval: '1h',
                limit: 100
            }
        });
        // Process response...
    } catch (error) {
        console.error('Error:', error);
    }
}

=====================================
STEP 4: PRODUCTION DEPLOYMENT
=====================================

For production deployment:

1. Use environment variables for API keys
2. Add rate limiting to prevent API abuse
3. Implement caching to reduce API calls
4. Use HTTPS for secure communication
5. Consider using PM2 for process management

Example with PM2:
npm install -g pm2
pm2 start server.js --name grid-bot-api
pm2 save
pm2 startup

=====================================
TROUBLESHOOTING
=====================================

1. CORS errors: Make sure your backend is running
2. Connection refused: Check if backend port is correct
3. API rate limits: Implement caching and rate limiting
4. Invalid API keys: Double-check your .env file

For more help, check the exchange API documentation:
- Binance: https://binance-docs.github.io/apidocs/
- Bybit: https://bybit-exchange.github.io/docs/
- Bitget: https://bitgetlimited.github.io/apidoc/
            `);
        }

        function updateMarketOverview() {
            // Calculate overall market metrics
            const bullishCount = marketData.filter(d => d.trend.direction === 'bullish').length;
            const totalCount = marketData.length;
            const bullishPercent = (bullishCount / totalCount) * 100;
            
            // Market trend
            let trendText = 'Neutral';
            let trendClass = 'text-yellow-400';
            if (bullishPercent > 65) {
                trendText = 'Bullish';
                trendClass = 'text-green-400';
            } else if (bullishPercent < 35) {
                trendText = 'Bearish';
                trendClass = 'text-red-400';
            }
            
            document.getElementById('market-trend').textContent = trendText;
            document.getElementById('market-trend').className = `text-2xl font-bold ${trendClass}`;
            document.getElementById('trend-strength').textContent = `${bullishPercent.toFixed(0)}% bullish`;
            
            const trendBar = document.getElementById('trend-bar');
            trendBar.style.width = `${bullishPercent}%`;
            trendBar.className = `h-2 rounded-full transition-all duration-500 ${
                bullishPercent > 65 ? 'bg-green-500' : bullishPercent < 35 ? 'bg-red-500' : 'bg-yellow-500'
            }`;
            
            // Fear & Greed (simulated)
            const fearGreed = 30 + Math.random() * 40;
            document.getElementById('fear-greed').textContent = fearGreed.toFixed(0);
            document.getElementById('fg-label').textContent = 
                fearGreed > 60 ? 'Greed' : fearGreed < 40 ? 'Fear' : 'Neutral';
            
            // BTC Dominance
            const btcDom = 45 + Math.random() * 10;
            document.getElementById('btc-dominance').textContent = btcDom.toFixed(1) + '%';
            document.getElementById('dom-change').textContent = 
                `${Math.random() > 0.5 ? '+' : '-'}${(Math.random() * 2).toFixed(1)}% 24h`;
            
            // Market Phase
            const phases = marketData.map(d => d.phase);
            const mostCommonPhase = phases.sort((a, b) =>
                phases.filter(v => v === a).length - phases.filter(v => v === b).length
            ).pop();
            
            document.getElementById('market-phase').textContent = mostCommonPhase;
            document.getElementById('phase-desc').textContent = 
                mostCommonPhase === 'Ranging' ? 'Perfect for grid bots' :
                mostCommonPhase === 'Accumulation' ? 'Consider long positions' :
                mostCommonPhase === 'Distribution' ? 'Take profits on longs' :
                'Mixed signals';
        }

        function renderOpportunitiesTable() {
            const tbody = document.getElementById('opportunities-table');
            const minScore = parseInt(document.getElementById('score-filter').value);
            const exchangeFilter = document.getElementById('exchange-filter').value;
            const conditionFilter = document.getElementById('condition-filter').value;
            
            let filteredData = marketData.filter(item => item.score >= minScore);
            
            // Apply exchange filter
            if (exchangeFilter !== 'all') {
                filteredData = filteredData.filter(item => item.exchange === exchangeFilter);
            }
            
            // Apply condition filter
            if (conditionFilter !== 'all') {
                filteredData = filteredData.filter(item => {
                    if (conditionFilter === 'trending') {
                        return item.trend.direction !== 'neutral' && item.trend.strength > 50;
                    } else if (conditionFilter === 'ranging') {
                        return item.phase === 'Ranging';
                    } else if (conditionFilter === 'volatile') {
                        return item.volatility > 7;
                    }
                    return true;
                });
            }
            
            // Sort by score descending
            filteredData.sort((a, b) => b.score - a.score);
            
            if (filteredData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" class="text-center p-8">No opportunities match your criteria</td></tr>';
                return;
            }
            
            tbody.innerHTML = filteredData.map(item => {
                const trendIcon = item.trend.direction === 'bullish' ? '' : 
                                 item.trend.direction === 'bearish' ? '' : '';
                const trendClass = item.trend.direction === 'bullish' ? 'trend-up' : 
                                  item.trend.direction === 'bearish' ? 'trend-down' : 'trend-neutral';
                
                return `
                    <tr class="bg-gray-800/30 border-b border-gray-700 hover:bg-gray-700/50 cursor-pointer"
                        onclick="showDetailedAnalysis('${item.pair}', '${item.exchange}')">
                        <td class="px-6 py-4 font-medium">${item.pair}</td>
                        <td class="px-6 py-4">
                            <span class="${trendClass}">
                                ${trendIcon} ${item.trend.direction}
                                <span class="text-xs">(${item.trend.strength.toFixed(0)}%)</span>
                            </span>
                        </td>
                        <td class="px-6 py-4">${item.price.toFixed(item.price > 100 ? 2 : 4)}</td>
                        <td class="px-6 py-4 ${item.change24h > 0 ? 'text-green-400' : 'text-red-400'}">
                            ${item.change24h > 0 ? '+' : ''}${item.change24h.toFixed(2)}%
                        </td>
                        <td class="px-6 py-4">
                            <div class="text-xs">
                                RSI: ${item.indicators.rsi.toFixed(0)}
                                <span class="text-gray-500">|</span>
                                MACD: ${item.indicators.macd}
                            </div>
                        </td>
                        <td class="px-6 py-4">${item.volatility.toFixed(2)}%</td>
                        <td class="px-6 py-4 ${item.fundingRate > 0 ? 'text-green-400' : 'text-red-400'}">
                            ${(item.fundingRate * 100).toFixed(4)}%
                            <span class="text-xs text-gray-400 block">${item.exchange}</span>
                        </td>
                        <td class="px-6 py-4">
                            <div class="flex items-center">
                                <div class="w-16 bg-gray-700 rounded-full h-2 mr-2">
                                    <div class="bg-indigo-500 h-2 rounded-full" style="width: ${item.score}%"></div>
                                </div>
                                <span class="text-xs">${item.score.toFixed(0)}</span>
                            </div>
                        </td>
                        <td class="px-6 py-4">
                            <span class="px-2 py-1 text-xs rounded-full ${getRecommendationColor(item.recommendation)}">
                                ${item.recommendation}
                            </span>
                        </td>
                        <td class="px-6 py-4 text-center">
                            <button class="text-indigo-400 hover:text-indigo-300" onclick="event.stopPropagation(); monitorPair('${item.pair}', '${item.exchange}')">
                                ${monitoredPairs.has(item.pair + '-' + item.exchange) ? 'Monitoring' : 'Monitor'}
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            updateLastUpdateTime();
        }

        function getRecommendationColor(rec) {
            const colors = {
                'Long Grid': 'bg-green-600/20 text-green-400',
                'Short Grid': 'bg-red-600/20 text-red-400',
                'Neutral Grid': 'bg-blue-600/20 text-blue-400',
                'Not Recommended': 'bg-gray-600/20 text-gray-400'
            };
            return colors[rec] || 'bg-gray-600/20 text-gray-400';
        }

        function initializeChart() {
            const ctx = document.getElementById('market-chart').getContext('2d');
            
            // Prepare data for BTC as example
            const btcData = marketData.find(d => d.pair === 'BTC/USDT');
            const labels = btcData.priceHistory.map((_, i) => i);
            
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'BTC/USDT',
                        data: btcData.priceHistory,
                        borderColor: 'rgb(99, 102, 241)',
                        backgroundColor: 'rgba(99, 102, 241, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => `Price: $${context.parsed.y.toFixed(2)}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#9CA3AF',
                                callback: (value) => '$' + value.toFixed(0)
                            }
                        }
                    }
                }
            });
        }

        function updateRecommendations() {
            // Best opportunities
            const bestOps = marketData
                .filter(d => d.score > 80)
                .sort((a, b) => b.score - a.score)
                .slice(0, 3);
            
            document.getElementById('best-opportunities').innerHTML = bestOps.map(op => `
                <div class="p-3 bg-gray-800 rounded-lg">
                    <p class="font-semibold">${op.pair}</p>
                    <p class="text-sm text-gray-400">${op.recommendation} - Score: ${op.score.toFixed(0)}</p>
                    <p class="text-xs text-green-400">Est. Daily: ${(op.volatility * 0.3).toFixed(2)}%</p>
                </div>
            `).join('');
            
            // Exit signals
            const exitSignals = marketData
                .filter(d => d.indicators.rsi > 70 || d.indicators.rsi < 30)
                .slice(0, 3);
            
            document.getElementById('exit-signals').innerHTML = exitSignals.map(sig => `
                <div class="p-3 bg-gray-800 rounded-lg">
                    <p class="font-semibold">${sig.pair}</p>
                    <p class="text-sm text-gray-400">RSI: ${sig.indicators.rsi.toFixed(0)} - ${sig.indicators.rsi > 70 ? 'Overbought' : 'Oversold'}</p>
                </div>
            `).join('') || '<p class="text-gray-500">No exit signals</p>';
            
            // Risk warnings
            const risks = marketData
                .filter(d => d.volatility > 10 || Math.abs(d.fundingRate) > 0.03)
                .slice(0, 3);
            
            document.getElementById('risk-warnings').innerHTML = risks.map(risk => `
                <div class="p-3 bg-gray-800 rounded-lg">
                    <p class="font-semibold">${risk.pair}</p>
                    <p class="text-sm text-gray-400">
                        ${risk.volatility > 10 ? `High volatility: ${risk.volatility.toFixed(1)}%` : 
                          `Extreme funding: ${(risk.fundingRate * 100).toFixed(3)}%`}
                    </p>
                </div>
            `).join('') || '<p class="text-gray-500">No warnings</p>';
        }

        function showDetailedAnalysis(pair) {
            const data = marketData.find(d => d.pair === pair);
            
            const modal = document.getElementById('modal-container');
            modal.innerHTML = `
                <div class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex justify-center items-center z-50">
                    <div class="bg-gray-800 rounded-lg shadow-2xl w-full max-w-4xl p-6 border border-gray-700 max-h-[90vh] overflow-y-auto">
                        <div class="flex justify-between items-center mb-6">
                            <h2 class="text-2xl font-bold">${pair} Detailed Analysis</h2>
                            <button onclick="closeModal()" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                        </div>
                        
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                                <h3 class="text-lg font-semibold mb-3">Market Conditions</h3>
                                <div class="space-y-3">
                                    <div class="p-3 bg-gray-900 rounded">
                                        <p class="text-sm text-gray-400">Trend Analysis</p>
                                        <p class="font-semibold ${data.trend.direction === 'bullish' ? 'text-green-400' : data.trend.direction === 'bearish' ? 'text-red-400' : 'text-yellow-400'}">
                                            ${data.trend.direction.toUpperCase()} (${data.trend.strength.toFixed(0)}% strength)
                                        </p>
                                    </div>
                                    <div class="p-3 bg-gray-900 rounded">
                                        <p class="text-sm text-gray-400">Technical Indicators</p>
                                        <p>RSI: ${data.indicators.rsi.toFixed(0)} ${data.indicators.rsi > 70 ? '(Overbought)' : data.indicators.rsi < 30 ? '(Oversold)' : ''}</p>
                                        <p>MACD: ${data.indicators.macd}</p>
                                        <p>Volatility: ${data.volatility.toFixed(2)}%</p>
                                    </div>
                                    <div class="p-3 bg-gray-900 rounded">
                                        <p class="text-sm text-gray-400">Funding Rate</p>
                                        <p class="${data.fundingRate > 0 ? 'text-green-400' : 'text-red-400'}">
                                            ${(data.fundingRate * 100).toFixed(3)}% / 8h
                                            <span class="text-xs text-gray-400">(${(data.fundingRate * 3 * 365).toFixed(1)}% APR)</span>
                                        </p>
                                    </div>
                                </div>
                            </div>
                            
                            <div>
                                <h3 class="text-lg font-semibold mb-3">Grid Bot Strategy</h3>
                                <div class="space-y-3">
                                    <div class="p-4 bg-indigo-900/30 rounded">
                                        <p class="font-semibold text-indigo-400">Recommended: ${data.recommendation}</p>
                                        <p class="text-sm mt-2">${getStrategyDescription(data)}</p>
                                    </div>
                                    <div class="p-3 bg-gray-900 rounded">
                                        <p class="text-sm text-gray-400">Suggested Parameters</p>
                                        <ul class="text-sm space-y-1 mt-2">
                                            <li> Price Range: ${data.volatility > 5 ? 15 : 10}%</li>
                                            <li> Grid Count: ${data.volatility > 6 ? '50-100' : '20-50'}</li>
                                            <li> Leverage: ${data.volatility > 7 ? '3-5x' : '5-10x'}</li>
                                            <li> Investment: Start with $500-2000</li>
                                        </ul>
                                    </div>
                                    <div class="p-3 bg-gray-900 rounded">
                                        <p class="text-sm text-gray-400">Risk Management</p>
                                        <ul class="text-sm space-y-1 mt-2">
                                            <li> Stop Loss: ${data.volatility * 2}% below range</li>
                                            <li> Take Profit: ${data.volatility * 3}% total PnL</li>
                                            <li> Max Drawdown: ${data.volatility}%</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mt-6 p-4 bg-yellow-900/20 rounded-lg border border-yellow-600/30">
                            <p class="text-yellow-400 font-semibold mb-2"> Market Alerts</p>
                            <ul class="text-sm space-y-1">
                                ${generateAlertConditions(data).map(alert => `<li> ${alert}</li>`).join('')}
                            </ul>
                        </div>
                        
                        <div class="mt-6 flex gap-4">
                            <button onclick="deployBot('${pair}')" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg">
                                Deploy Grid Bot
                            </button>
                            <button onclick="monitorPair('${pair}'); closeModal();" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg">
                                Add to Monitor
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function getStrategyDescription(data) {
            if (data.recommendation === 'Long Grid') {
                return 'Market shows bullish momentum with reasonable funding rates. Set up a long-biased grid to capture upward movement while earning from volatility.';
            } else if (data.recommendation === 'Short Grid') {
                return 'High funding rates and bearish indicators suggest shorting opportunity. Deploy a short-biased grid to earn funding while profiting from downward movement.';
            } else if (data.recommendation === 'Neutral Grid') {
                return 'Market is ranging with good volatility. Perfect for neutral grid strategy to profit from price oscillations without directional bias.';
            } else {
                return 'Low volatility and unclear trend make this pair unsuitable for grid trading currently. Wait for better market conditions.';
            }
        }

        function generateAlertConditions(data) {
            const alerts = [];
            
            if (data.trend.direction === 'bullish' && data.indicators.rsi < 70) {
                alerts.push('Exit long positions if RSI exceeds 70 or trend weakens');
            }
            if (data.volatility > 10) {
                alerts.push('High volatility - consider reducing position size');
            }
            if (Math.abs(data.fundingRate) > 0.02) {
                alerts.push('Extreme funding rate - monitor for potential reversal');
            }
            if (data.phase === 'Distribution') {
                alerts.push('Market in distribution phase - be ready to take profits');
            }
            
            return alerts.length > 0 ? alerts : ['No immediate concerns - continue monitoring'];
        }

        function monitorPair(pair) {
            monitoredPairs.add(pair);
            addAlert('info', `Started monitoring ${pair}`);
            renderOpportunitiesTable();
        }

        function addAlert(type, message) {
            const alert = {
                id: Date.now(),
                type,
                message,
                timestamp: new Date()
            };
            
            alerts.unshift(alert);
            if (alerts.length > 10) alerts.pop();
            
            renderAlerts();
        }

        function renderAlerts() {
            const container = document.getElementById('alerts-container');
            
            if (alerts.length === 0) {
                container.innerHTML = '<p class="text-gray-500 text-center">No recent alerts</p>';
                return;
            }
            
            container.innerHTML = alerts.map(alert => {
                const typeColors = {
                    'info': 'border-blue-500 bg-blue-500/10',
                    'warning': 'border-yellow-500 bg-yellow-500/10',
                    'danger': 'border-red-500 bg-red-500/10',
                    'success': 'border-green-500 bg-green-500/10'
                };
                
                return `
                    <div class="p-3 rounded-lg border ${typeColors[alert.type] || typeColors.info}">
                        <p class="text-sm">${alert.message}</p>
                        <p class="text-xs text-gray-500 mt-1">${alert.timestamp.toLocaleTimeString()}</p>
                    </div>
                `;
            }).join('');
        }

        function startRealTimeUpdates() {
            // Simulate market changes
            setInterval(() => {
                marketData.forEach(item => {
                    // Update prices
                    const change = (Math.random() - 0.5) * 0.002;
                    item.price *= (1 + change);
                    item.priceHistory.push(item.price);
                    if (item.priceHistory.length > 100) item.priceHistory.shift();
                    
                    // Recalculate indicators
                    const analysis = analyzeMarketCondition({ price: item.price, priceHistory: item.priceHistory });
                    item.trend = analysis.trend;
                    item.indicators.rsi = TechnicalIndicators.calculateRSI(item.priceHistory);
                    item.volatility = analysis.volatility;
                    
                    // Check for alerts
                    checkAlertConditions(item);
                });
                
                renderOpportunitiesTable();
                updateMarketOverview();
                updateRecommendations();
            }, 5000);
        }

        function checkAlertConditions(item) {
            if (!monitoredPairs.has(item.pair)) return;
            
            // Check various alert conditions
            if (document.getElementById('alert-trend-change').checked) {
                // Simplified trend change detection
                if (Math.random() < 0.05) {
                    addAlert('warning', `${item.pair}: Trend change detected - review strategy`);
                }
            }
            
            if (document.getElementById('alert-volatility').checked && item.volatility > 15) {
                addAlert('danger', `${item.pair}: High volatility spike (${item.volatility.toFixed(1)}%)`);
            }
            
            if (document.getElementById('alert-funding').checked && Math.random() < 0.03) {
                addAlert('info', `${item.pair}: Funding rate flipped to ${item.fundingRate > 0 ? 'positive' : 'negative'}`);
            }
            
            if (document.getElementById('alert-indicators').checked && (item.indicators.rsi > 75 || item.indicators.rsi < 25)) {
                addAlert('warning', `${item.pair}: RSI extreme (${item.indicators.rsi.toFixed(0)})`);
            }
        }

        function setupEventListeners() {
            // Filters
            document.getElementById('score-filter').addEventListener('input', (e) => {
                document.getElementById('score-value').textContent = e.target.value;
                renderOpportunitiesTable();
            });

            document.getElementById('exchange-filter').addEventListener('change', renderOpportunitiesTable);
            document.getElementById('condition-filter').addEventListener('change', renderOpportunitiesTable);
            document.getElementById('timeframe-filter').addEventListener('change', initializeMarket);
            
            document.getElementById('refresh-analysis').addEventListener('click', () => {
                initializeMarket();
                addAlert('success', 'Market analysis refreshed');
            });
            
            // Alert settings are already set up with checkboxes

            document.getElementById('fetch-balance-btn').addEventListener('click', fetchAccountBalance);
        }

        function closeModal() {
            document.getElementById('modal-container').innerHTML = '';
        }

        function deployBot(pair) {
            alert(`Grid bot deployment for ${pair} would be initiated here`);
            closeModal();
        }

        function updateLastUpdateTime() {
            const now = new Date();
            document.getElementById('last-update').textContent = now.toLocaleTimeString('en-US', { hour12: false });
        }

        async function fetchAccountBalance() {
            const container = document.getElementById('account-info-container');
            const button = document.getElementById('fetch-balance-btn');
            container.innerHTML = '<div class="flex items-center"><div class="loading-spinner h-6 w-6 border-2"></div><p class="ml-2">Fetching balance...</p></div>';
            button.disabled = true;

            try {
                if (!API_CONFIG.backendUrl) {
                    throw new Error('Backend proxy not configured.');
                }

                const response = await axios.get(`${API_CONFIG.backendUrl}/api/bitget/account/wallet`);
                
                if (response.data.code === '00000' && response.data.data.length > 0) {
                    const usdtAccount = response.data.data[0];
                    container.innerHTML = `
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-white">
                            <div><span class="text-gray-400">Available:</span> $${parseFloat(usdtAccount.available).toFixed(2)}</div>
                            <div><span class="text-gray-400">Equity:</span> $${parseFloat(usdtAccount.equity).toFixed(2)}</div>
                            <div><span class="text-gray-400">Unrealized PNL:</span> <span class="${parseFloat(usdtAccount.unrealizedPL) >= 0 ? 'text-green-400' : 'text-red-400'}">$${parseFloat(usdtAccount.unrealizedPL).toFixed(2)}</span></div>
                            <div><span class="text-gray-400">Realized PNL:</span> <span class="${parseFloat(usdtAccount.realizedPL) >= 0 ? 'text-green-400' : 'text-red-400'}">$${parseFloat(usdtAccount.realizedPL).toFixed(2)}</span></div>
                        </div>
                    `;
                } else {
                    throw new Error(response.data.msg || 'Failed to fetch balance. Check server logs and API keys.');
                }
            } catch (error) {
                console.error('Error fetching account balance:', error);
                container.innerHTML = `<p class="text-red-400"><strong>Error:</strong> ${error.message}</p>`;
            } finally {
                button.disabled = false;
            }
        }
    </script>
</body>
</html>